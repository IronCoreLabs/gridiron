extern crate num_traits;
#[cfg(test)]
extern crate rand;
#[cfg(test)]
#[macro_use]
extern crate proptest;

#[macro_use]
pub mod digits {
    #[macro_use]
    pub mod ff31;
    pub(crate) mod constant_bool;
    pub(crate) mod constant_time_primitives;
}

// p = 3121577065842246806003085452055281276803074876175537384188619957989004527066410274868798956582915008874704066849018213144375771284425395508176023
//   =
fp31!(
    fp_480, // Name of mod
    Fp480,  // Name of class
    480,    // Number of bits for prime
    16,     // Number of limbs (ceil(bits/31))
    [
        // prime number in limbs, least sig first
        // get this from sage with p.digits(2^31)
        1055483031, 1386897616, 898494285, 1391857335, 488544832, 1799384686, 193115992, 565079768,
        190358044, 1260077487, 1583277252, 222489098, 760385720, 330553579, 429458313, 32766
    ],
    // barrett reduction for reducing values up to twice
    // the number of prime bits (double limbs):
    // floor(2^(31*numlimbs*2)/p).digits(2^31)
    [
        867470981, 808770461, 73326154, 873519719, 731426156, 154316581, 1066899290, 1406793571,
        1662108208, 231227174, 1893732143, 1300610845, 325218135, 866248622, 1596183093,
        1288991726, 65539
    ],
    // montgomery R = 2^(W*N) where W = word size and N = limbs
    //            R = 2^(16*31) = 2^496
    // montgomery R^-1 mod p
    // 540164672828597150601552066704871144340865164390233716165828766698348036766646674962138582407269471436938515957052715279568068096452253665449178
    [
        172371756, 1046460578, 1674812214, 732914258, 1831602581, 1542423573, 2092897579,
        735180796, 1991677061, 919723849, 802444109, 1677449578, 1892606677, 1820724059,
        1324905779, 16249
    ],
    // montgomery R^2 mod p
    // 457845372202231092221045514406304715517609899600516288088351276206864288839367561156406646278891945147846188034105187428603489846554823930520200
    [
        197589901, 1933752831, 580428568, 527417626, 249573438, 264164054, 609560334, 32358085,
        944568904, 1556682934, 1807973447, 1881920392, 10254137, 588677610, 1214264513, 6960
    ],
    // -p[0]^-1
    // in sage: m = p.digits(2^31)[0]
    //          (-m).inverse_mod(2^31)
    1345299673
);

// p = 65000549695646603732796438742359905742825358107623003571877145026864184071783
fp31!(
    fp_256, // Name of mod
    Fp256,  // Name of class
    256,    // Number of bits for prime
    9,      // Number of limbs (ceil(bits/31))
    [
        // prime number in limbs, least sig first
        // get this from sage with p.digits(2^31)
        1577621095, 817453272, 47634040, 1927038601, 407749150, 1308464908, 685899370, 1518399909,
        143
    ],
    // barrett reduction for reducing values up to twice
    // the number of prime bits (double limbs):
    // floor(2^(31*numlimbs*2)/p)
    [
        618474456, 1306750627, 1454330209, 2032300189, 1138536719, 1905629153, 1016481908,
        1139000707, 1048853973, 14943480
    ],
    // montgomery R = 2^(W*N) where W = word size and N = limbs
    //            R = 2^(9*31) = 2^279
    // montgomery R^-1 mod p
    // 41128241662407537452081084990737892697811449013582128001435272241165411523443
    [
        1126407027, 1409097648, 718270744, 92148126, 1120340506, 1733383256, 1472506103,
        1994474164, 90
    ],
    // montgomery R^2 mod p
    // 26753832205083639112203412356185740914827891884263043594389452794758614404120
    [
        1687342104, 733402836, 182672516, 801641709, 2122695487, 1290522951, 66525586, 319877849,
        59
    ],
    // -p[0]^-1
    // in sage: m = p.digits(2^31)[0]
    //          (-m).inverse_mod(2^31)
    2132269737
);

impl From<[u8; 64]> for fp_256::Fp256 {
    fn from(src: [u8; 64]) -> Self {
        let mut limbs = [0u32; 18];
        fp_256::convert_bytes_to_limbs_mut(&src, &mut limbs, 64);
        fp_256::Fp256::new(fp_256::Fp256::reduce_barrett(&limbs))
    }
}

impl From<[u8; 64]> for fp_480::Fp480 {
    fn from(src: [u8; 64]) -> Self {
        let mut limbs = [0u32; 32];
        fp_256::convert_bytes_to_limbs_mut(&src, &mut limbs, 64);
        fp_480::Fp480::new(fp_480::Fp480::reduce_barrett(&limbs))
    }
}

#[cfg(test)]
mod lib {
    use super::*;
    use num_traits::{Inv, One, Pow, Zero};
    use std::ops::{Div, Mul};

    // #[test]
    // fn normalize() {
    //     // pplusone = fp_480::PRIME + 1
    //     let pplusone = fp_480::Fp480::new([
    //         7590025971293054104,
    //         747247717039963091,
    //         7159038352024529316,
    //         2036573563714931421,
    //         3541392403947280546,
    //         829128924894566329,
    //         1019112720967587113,
    //         4294731364,
    //     ]);
    //     assert_eq!(pplusone.normalize_little(0), fp_480::Fp480::one());

    //     let ptimestwo = fp_480::Fp480::new([
    //         15180051942586108206,
    //         1494495434079926182,
    //         14318076704049058632,
    //         4073147127429862842,
    //         7082784807894561092,
    //         1658257849789132658,
    //         2038225441935174226,
    //         8589462728,
    //     ]);
    //     assert_eq!(ptimestwo.normalize_big(0), fp_480::Fp480::zero());

    //     let ptimestwominusone = fp_480::Fp480::new([
    //         15180051942586108205,
    //         1494495434079926182,
    //         14318076704049058632,
    //         4073147127429862842,
    //         7082784807894561092,
    //         1658257849789132658,
    //         2038225441935174226,
    //         8589462728,
    //     ]);
    //     assert_eq!(
    //         ptimestwominusone.normalize_little(0),
    //         fp_480::Fp480::zero() - fp_480::Fp480::one()
    //     );

    //     let ptimesthreeplusone = fp_480::Fp480::new([
    //         4323333840169610694,
    //         2241743151119889274,
    //         3030370982364036332,
    //         6109720691144794264,
    //         10624177211841841638,
    //         2487386774683698987,
    //         3057338162902761339,
    //         12884194092,
    //     ]);
    //     assert_eq!(ptimesthreeplusone.normalize_big(0), fp_480::Fp480::one());

    //     // so we should never have a number
    //     // greater than 2p, which means all F's
    //     // would be invalid for fp480
    //     let max = fp_480::Fp480::new([
    //         0xFFFFFFFFFFFFFFFFu64,
    //         0xFFFFFFFFFFFFFFFFu64,
    //         0xFFFFFFFFFFFFFFFFu64,
    //         0xFFFFFFFFFFFFFFFFu64,
    //         0xFFFFFFFFFFFFFFFFu64,
    //         0xFFFFFFFFFFFFFFFFu64,
    //         0xFFFFFFFFFFFFFFFFu64,
    //         0x00000000FFFFFFFFu64,
    //     ]);
    //     // as determined by sage
    //     let expected = fp_480::Fp480::new([
    //         10856718102416497512,
    //         17699496356669588524,
    //         11287705721685022299,
    //         16410170509994620194,
    //         14905351669762271069,
    //         17617615148814985286,
    //         17427631352741964502,
    //         235931,
    //     ]);
    //     assert_eq!(max.normalize_big(0), expected);
    // }

    // #[test]
    // fn is_normalized() {
    //     let big = fp_480::Fp480::new([0xffffffffu64; fp_480::NUMLIMBS]);
    //     let p = fp_480::Fp480::new(fp_480::PRIME);
    //     let one = fp_480::Fp480::one();
    //     assert!(p + one < p);
    //     assert!(one - p < p);
    //     assert!(big * big < p);
    //     assert!(big.pow(3) < p);
    // }

    #[test]
    fn mont_mult1() {
        // 95268205315236501484672006935066056413858283446892086784168052156537964209835102730449048569806878637400128131440203902086374553015554146305
        let a = fp_480::Fp480::new([1u32; fp_480::NUMLIMBS]);
        // a * a % fp_480::PRIME =
        // 205669314559023345249322393444938088201822776871146042137485986789672375071531284450979897790335457986807231101745728970499097028834583423134417
        let expected = fp_480::Fp480::new([
            116566737, 258320304, 899113910, 662693571, 1878328939, 137325967, 973027057,
            1096098811, 1800707178, 257433595, 567863213, 586185298, 1453955551, 666215613,
            1815208656, 2158,
        ]);
        assert_eq!((a.to_monty() * a.to_monty()).to_norm(), expected);
    }

    #[test]
    fn mont_mult2() {
        // 452312848793890971808518248247112008541969316111895757139568199407784427521
        let a = fp_256::Fp256::new([1u32; fp_256::NUMLIMBS]);
        // a * R % fp_256::PRIME = 27935760211609813813226455184238240888269395514922035446130060411072102193610
        let expected = fp_256::Fp256::new([
            1001314762, 222542809, 1966841077, 1532144542, 1509311353, 1324885496, 689426205,
            1636449281, 61,
        ]);
        assert_eq!(a.to_monty().limbs, expected.limbs);
    }

    #[test]
    fn static_add_31_bit() {
        //41389210591178563197866013531977652355280622370776165812970320099896695112225
        let expected = fp_256::Fp256::new([
            1687077409, 1547669063, 1685320481, 1036948901, 4206667, 1832642533, 59073627,
            1086014588, 91,
        ]);
        //53194880143412583465331226137168779049052990239199584692423732563380439592004
        let a = fp_256::Fp256::new([
            558607428, 108819344, 866477261, 408251927, 1279719733, 496811896, 1446228323,
            1302207248, 117,
        ]);
        assert_eq!(a + a, expected);
    }

    #[test]
    fn static_div_31_bit() {
        //32500274847823301866398219371179952871412679053811501785938572513432092035892
        let result = fp_256::Fp256::new([
            788810548, 408726636, 1097558844, 963519300, 203874575, 654232454, 1416691509,
            1832941778, 71,
        ]);
        //41389210591178563197866013531977652355280622370776165812970320099896695112225
        let b = fp_256::Fp256::new([
            1687077409, 1547669063, 1685320481, 1036948901, 4206667, 1832642533, 59073627,
            1086014588, 91,
        ]);
        //53194880143412583465331226137168779049052990239199584692423732563380439592004
        let a = fp_256::Fp256::new([
            558607428, 108819344, 866477261, 408251927, 1279719733, 496811896, 1446228323,
            1302207248, 117,
        ]);
        assert_eq!(a / b, result);
        assert_eq!(result * b, a);
    }

    #[test]
    fn static_co_reduce_256_bit() {
        let a_result = [
            2102762755, 340721811, 1526670465, 1233221938, 1621045422, 3878, 0, 0, 0,
        ];
        let b_result = [
            496048871, 1583721686, 351053136, 72635571, 14163922, 1245, 0, 0, 0,
        ];
        let mut a = [
            2003540029, 1136642599, 2013451521, 1081750855, 2108178975, 1491192821, 4, 0, 0,
        ];
        let mut b = [
            2089475485, 1450247307, 1692152066, 1263335112, 856386648, 2075289019, 25, 0, 0,
        ];
        let pa = 6648347;
        let pb = -1201787;
        let qa = -12242368;
        let qb = 2213312;
        fp_256::Fp256::co_reduce(&mut a, &mut b, pa, pb, qa, qb);
        assert_eq!(a, a_result);
        assert_eq!(b, b_result);
    }

    #[test]
    fn fp_256_31_normalize_prime_minus_1() {
        let a = fp_256::Fp256::new([
            1577621094, 817453272, 47634040, 1927038601, 407749150, 1308464908, 685899370,
            1518399909, 143,
        ]);
        let result = a.normalize_little();
        assert_eq!(a, result);
    }

    // #[test]
    // fn hex_dec_print() {
    //     let p = fp_480::Fp480::new(fp_480::PRIME);
    //     assert_eq!(p.to_str_decimal().as_str(),  "3121577065842246806003085452055281276803074876175537384188619957989004527066410274868798956582915008874704066849018213144375771284425395508176023");
    //     assert_eq!(p.to_str_hex().as_str(),  "fffc66640e249d9ec75ad5290b81a85d415797b931258da0d78b58a21c435cddb02e0add635a037371d1e9a40a5ec1d6ed637bd3695530683ee96497");

    //     let p = fp_256::Fp256::new(fp_256::PRIME);
    //     assert_eq!(
    //         p.to_str_decimal().as_str(),
    //         "65000549695646603732796438742359905742825358107623003571877145026864184071783"
    //     );
    //     assert_eq!(
    //         p.to_str_hex().as_str(),
    //         "8fb501e34aa387f9aa6fecb86184dc21ee5b88d120b5b59e185cac6c5e089667"
    //     );

    //     let mut bytes = [0u8; 32];
    //     bytes[0] = 255;
    //     // actual result here is mod PRIME
    //     assert_eq!(
    //         fp_256::Fp256::from(bytes).to_str_decimal().as_str(),
    //         "50339226693086325302401222106137814970392790680417402014301307793518034905497"
    //     );
    // }

    // #[test]
    // fn dec_print() {
    //     let p = fp_480::Fp480::new(fp_480::PRIME);
    //     assert_eq!(p.to_str_decimal(),  "3121577065842246806003085452055281276803074876175537384188619957989004527066410274868798956582915008874704066849018213144375771284425395508176023");
    // }

    #[test]
    fn zero1() {
        let a = fp_480::Fp480::new([1u32; fp_480::NUMLIMBS]);
        assert_eq!(a - a, fp_480::Fp480::zero());
        assert_eq!(a + fp_480::Fp480::zero(), a);
        assert_eq!(a * fp_480::Fp480::zero(), fp_480::Fp480::zero());
    }

    #[test]
    fn mul_precalc() {
        // a = 95268205315236501484672006935066056413858283446892086784168052156537964209835102730449048569806878637400128131440203902086374553015554146305
        let a = fp_480::Fp480::new([1u32; fp_480::NUMLIMBS]);
        // a * a % fp_480::PRIME =
        // 205669314559023345249322393444938088201822776871146042137485986789672375071531284450979897790335457986807231101745728970499097028834583423134417
        let expected = fp_480::Fp480::new([
            116566737, 258320304, 899113910, 662693571, 1878328939, 137325967, 973027057,
            1096098811, 1800707178, 257433595, 567863213, 586185298, 1453955551, 666215613,
            1815208656, 2158,
        ]);
        assert_eq!(a * a, expected);
    }

    // #[test]
    // fn static_number_tests() {
    //     // static values from sage
    //     // let a = fp_480::Fp480::new_from_string("1849730734868681485455534012483517011951239946690093506001286715509796248056543867438342930397280622761994677963488469871518585836942949575474581", 10).unwrap();
    //     let a = fp_480::Fp480::new([
    //         12373281137873304981,
    //         3364574066891759603,
    //         18249495978001488097,
    //         7121407741097929457,
    //         17616622123341604582,
    //         999548323268666092,
    //         102536279974639920,
    //         2544898439,
    //     ]);
    //     // let b = fp_480::Fp480::new_from_string("1427839274828296696112450624937180081894366106872726190963907037699726644896926911406125127099508401951977447182118568992280201726037533400584114", 10).unwrap();
    //     let b = fp_480::Fp480::new([
    //         13786755668808912818,
    //         10295850694267584116,
    //         6281259092835536344,
    //         15649415232981746878,
    //         8768243465836405520,
    //         8938625549723856276,
    //         4465923072383974360,
    //         1964451297,
    //     ]);
    //     assert_eq!(
    //         fp_480::Fp480::zero() - fp_480::Fp480::one(),
    //         fp_480::Fp480::new(fp_480::PRIME) - fp_480::Fp480::one()
    //     );
    //     assert_eq!(
    //         a + b,
    //         fp_480::Fp480::new([
    //             123266761679612080,
    //             12913177044119380629,
    //             17371716718812495125,
    //             2287505336655193298,
    //             4396729111521177941,
    //             9109044948097956040,
    //             3549346631391027167,
    //             214618372
    //         ])
    //     );

    //     assert_eq!(
    //         b - a,
    //         fp_480::Fp480::new([
    //             9003500502228661940,
    //             7678524344415787604,
    //             13637545540568129179,
    //             10564581055598748841,
    //             13139757820151633100,
    //             8768206151349756512,
    //             5382499513376921553,
    //             3714284222
    //         ])
    //     );
    //     assert_eq!(
    //         a - b,
    //         fp_480::Fp480::new([
    //             17033269542773943779,
    //             11515467446333727102,
    //             11968236885165951752,
    //             9918736581825734195,
    //             8848378657505199061,
    //             10507666847254361432,
    //             14083357281300217175,
    //             580447141
    //         ])
    //     );
    //     assert_eq!(
    //         fp_480::Fp480::one() - a,
    //         fp_480::Fp480::new([
    //             13663488907129300739,
    //             15829417723857755103,
    //             7356286447732592834,
    //             13361909896326553579,
    //             4371514354315227579,
    //             18276324675335451852,
    //             916576440992947192,
    //             1749832925
    //         ])
    //     );
    // }

    // #[test]
    // fn identity_single_case() {
    //     let b = fp_480::Fp480::new([
    //         3834872116353127868,
    //         4590656380457259402,
    //         9262714631161821576,
    //         12699347707666498727,
    //         8045166865395528593,
    //         11972162468224368488,
    //         7066104462708830816,
    //         3771584138,
    //     ]);
    //     let binverse = fp_480::Fp480::new([
    //         8359496029866312121,
    //         9855680935361061958,
    //         9721984913593910889,
    //         9699886586609381252,
    //         1495521600225809240,
    //         9137980985416018882,
    //         8475132370731740574,
    //         938930668,
    //     ]);
    //     assert_eq!(b.inv(), binverse);
    //     assert_eq!(b.mul(b.inv()), fp_480::Fp480::one());
    //     assert_eq!(b.div(b), fp_480::Fp480::one());

    //     let b = fp_480::Fp480::new([
    //         0xf94961046cc2343d,
    //         0x54e7fe7a0c15bf98,
    //         0x92c968b7a5dc19e6,
    //         0x134c24513c8e50bf,
    //         0xdd5d0558255e2bfe,
    //         0xe2e7b5df97c40138,
    //         0x784c26b25d56ca9b,
    //         0xec1d97d8,
    //     ]);
    //     let binverse = fp_480::Fp480::new([
    //         3964041005206816693,
    //         17748359409173047324,
    //         8574914009989265896,
    //         11108665920023441573,
    //         3240235572120937559,
    //         17453993893625142484,
    //         4629261177586478425,
    //         3466826655,
    //     ]);
    //     assert_eq!(b.inv(), binverse);
    //     assert_eq!(b.mul(b.inv()), fp_480::Fp480::one());
    //     assert_eq!(b.div(b), fp_480::Fp480::one());
    // }

    // #[test]
    // fn div_single_case() {
    //     let a = fp_480::Fp480::new([
    //         2816712066946153747,
    //         5747042474327040776,
    //         15535406302961972262,
    //         16460818219144805138,
    //         6994911687676264632,
    //         12521802401546148605,
    //         9581905044881715501,
    //         3587491159,
    //     ]);
    //     let ainv = fp_480::Fp480::new([
    //         13654897055858194021,
    //         3339211318812279773,
    //         6858620690097655194,
    //         8897541996364047054,
    //         15724927113891581668,
    //         13694193647356111498,
    //         18416317810762613951,
    //         2200872997,
    //     ]);
    //     assert_eq!(a.inv(), ainv);

    //     let numerator = fp_480::Fp480::new([
    //         8348794426534327563,
    //         1879903001149673731,
    //         12837080870514459017,
    //         700911462630613964,
    //         9433880464073972719,
    //         1278767469094518492,
    //         18251606839666179829,
    //         2954588469,
    //     ]);
    //     let result = fp_480::Fp480::new([
    //         17013347194150995858,
    //         12466908776327473270,
    //         2481475576127098196,
    //         16975279220818532667,
    //         17740556660822707130,
    //         11848543690922999332,
    //         14202304424715009844,
    //         2162127586,
    //     ]);

    //     // numerator / a = result
    //     assert_eq!(numerator / a, result);

    //     let numerator = fp_480::Fp480::new([
    //         5173569617009464247,
    //         3223239650780825717,
    //         11226163026039631204,
    //         4560913629967781597,
    //         14321350974822713880,
    //         1294566703500450391,
    //         2384188416395534881,
    //         3289683177,
    //     ]);
    //     let denominator = fp_480::Fp480::new([
    //         3124894097069768307,
    //         14602323645599167979,
    //         13720940325689005600,
    //         11251012007713449105,
    //         3928127865078497824,
    //         2336440514434006119,
    //         8720211081311112793,
    //         2171615668,
    //     ]);
    //     let expected = fp_480::Fp480::new([
    //         145916248207258317,
    //         3571538994930808453,
    //         15848624085546498523,
    //         18371007075928284529,
    //         622524464600606627,
    //         14215098719906011444,
    //         4689483692729775607,
    //         3264262622,
    //     ]);

    //     let denominator_inverse = fp_480::Fp480::new([
    //         5194245210418602010,
    //         10809886684582169141,
    //         5666673393015102841,
    //         7341667117682842000,
    //         15709100179662702910,
    //         12435149750834608475,
    //         3861253510626063302,
    //         2159848540,
    //     ]);
    //     assert_eq!(denominator.inv(), denominator_inverse);
    //     assert_eq!(numerator / denominator, expected);

    //     // failure case from mul_equals_div
    //     let a = fp_480::Fp480::new([
    //         0x63b7da3a4e2d8e00,
    //         0x7e0d4680b329bb99,
    //         0x72d8a3f862f3fd88,
    //         0x53eda8ce171d68b3,
    //         0x7a2131869ec4ed19,
    //         0x59da4f56f5c945d2,
    //         0x85ae5a2efaf37c1d,
    //         0xbfc67cea,
    //     ]);
    //     let b = fp_480::Fp480::new([
    //         0x16ab759419cc4100,
    //         0x5014fe9dccb413a5,
    //         0x65493b2c5cabcdf7,
    //         0x154666ed0538f953,
    //         0x59cba9f0f5f2e84b,
    //         0x8d1a5d247b179226,
    //         0x731a78943d9db123,
    //         0xd02cf669,
    //     ]);
    //     let c = fp_480::Fp480::new([
    //         11693783694811866307,
    //         245594065984987110,
    //         322736986052945757,
    //         2942266530865397599,
    //         17072191670499601912,
    //         15567716623030039384,
    //         10534201835020433733,
    //         2741051863,
    //     ]);
    //     assert_eq!(a * b, c);
    //     assert_eq!(c / b, a);
    //     assert_eq!(c / a, b);
    // }
    #[test]
    fn barrett_reduction() {
        // max
        // let yuuuuge = [
        //     1717850385, 975992930, 1085120981, 290253968, 541414174, 1010009590, 992858995,
        //     1544978906, 479141764, 595912303, 1182831228, 1732726309, 208474352, 431120126,
        //     1041596558, 2047733944, 736903860, 964324177, 245966458, 1453527551, 1075327941,
        //     2050995692, 1443163149, 1018800365, 275337413, 1465124270, 409168091, 1829798574,
        //     231461389, 574854543, 1073623861, 0,
        // ]; // p^2 in 31 bit limbs
        // assert_eq!(fp_480::Fp480::reduce_barrett(&yuuuuge), [0u32; 16]);

        // let max = [
        //     1657593201, 1540832074, 1649487609, 580760650, 1029551730, 2022468362, 1718453138,
        //     429469137, 2035023273, 199629839, 1710284256, 907874956, 1233314842, 1123865686,
        //     1935834002, 1544277094, 20651, 0,
        // ]; // p^2
        // assert_eq!(fp_256::Fp256::reduce_barrett(&max), [0u32; 9]);

        // 2*p = 0
        // let twop = [
        //     2110966062, 626311584, 1796988571, 636231022, 977089665, 1451285724, 386231985,
        //     1130159536, 380716088, 372671326, 1019070857, 444978197, 1520771440, 661107158,
        //     858916626, 65532, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // ]; // padded to be DOUBLENUMLIMBS long
        // assert!(
        //     fp_480::Fp480::reduce_barrett(&twop)
        //         .iter()
        //         .all(|limb| *limb == 0)
        // );

        // p * p = 0
        // (p-5)*(p-4) = p^2 - 4p - 5p + 20 -- any multiple of p is zero, so = 20

        // Arbitrary big number x < p:
        // 1207811257040831621391376042066624303968527700717084310097981686745089556997378024160906781595716428319582984800146428900609196302855174292951579
        // x * x =
        // 1458808032634553832917799193961797434235419188246642318697058264038385049089265036191575901553853582615536794361502971074563184673635362176350783892004837696732862760694621978178376129161721367027911973240921051380566691956112820757574780900407857583461168170860656255046949060119638593241
        // x * x mod p =
        // 1809287164707112312378003899038518547656481275056607132587933524119638354881446495182091979711134781179141557515395208880017070421464511373264455
        // let xsquared = [
        //     1256476377, 2102446331, 1632594058, 1382086562, 1977188283, 1189833019, 98505500,
        //     386297644, 482637868, 751487015, 968545410, 1465590326, 1636829572, 1068997602,
        //     2112274040, 675780054, 69810239, 774249708, 1799903083, 2117638065, 492942939,
        //     1246496911, 1605644669, 704647290, 1852334453, 1325788175, 178848546, 1997374434,
        //     1793336617, 22325931, 160731937,0
        // ];
        // let expected = [
        //     869156423, 665057899, 1391192655, 894967811, 1796343620, 436717649, 1265537281,
        //     727485642, 573430722, 980187994, 1374252810, 1447922940, 438926278, 1658380520,
        //     1097281981, 18991,
        // ];
        // assert_eq!(fp_480::Fp480::reduce_barrett(&xsquared), expected);
    }

    // #[test]
    // fn debug_output_test256() {
    //     let other = fp_256::Fp256::new([0, 0, 0x00FFFFFFFFFFFFFFu64, 0]);
    //     let str = format!("debug: {:?}, decimal: {}, hex: {:x}", other, other, other);
    //     assert_eq!(&str.replace(" ", ""), "debug:Fp256(0x0,0x0,0xffffffffffffff,0x0),decimal:24519928653854221393451185513466483474525218523169423360,hex:0x000000000000000000ffffffffffffff00000000000000000000000000000000");
    // }

    #[test]
    fn neg_test256() {
        let a = fp_256::Fp256::one();
        let b = fp_256::Fp256::new([
            136300585, 707444127, 807555021, 1811877557, 2098044538, 317321736, 1206406714, 25, 0,
        ]);
        assert_eq!(a * b, b);
        assert_eq!(-a * b, -b);
    }

    // #[test]
    // fn concrete_dist_assoc_norm() {
    //     let a = fp_256::Fp256::new([
    //         0xb12fb5043850e628,
    //         0xd7bab085515748e0,
    //         0x9b7355be1d204ae6,
    //         0x860ac8b5,
    //     ]);
    //     let b = fp_256::Fp256::new([
    //         0x2123ef649ef49cd4,
    //         0x8da4e712c8bdff77,
    //         0xb3799bf0e3bd329c,
    //         0x926e001c,
    //     ]);
    //     let c = fp_256::Fp256::new([
    //         10773964068678169461,
    //         7781056686061812801,
    //         7705577838994800718,
    //         91624696780573940,
    //     ]);
    //     assert_eq!(a * b, c);
    //     assert_eq!(c / a, b);
    //     assert_eq!(c * a.inv(), b);

    //     let a = fp_256::Fp256::new([
    //         0xb8b64011623c018a,
    //         0xddb38c295bc94eba,
    //         0x6cd16ea46cd6bd8f,
    //         0xd4d302ca,
    //     ]);
    //     let b = fp_256::Fp256::new([
    //         0x523d205e45ad60fc,
    //         0x21508a6d679848b0,
    //         0xf36e0f4429ce3982,
    //         0xf22e03e8,
    //     ]);
    //     let c = fp_256::Fp256::new([
    //         0x99343d8586c2db10,
    //         0x1dd26e85bda07d10,
    //         0xa59686b61a629965,
    //         0xd7cf30d3,
    //     ]);
    //     let expected = fp_256::Fp256::new([
    //         15795495403639475627,
    //         12400987731118697860,
    //         2558584020451078739,
    //         8223335412293341181,
    //     ]);
    //     let x = [
    //         17550962939841192978,
    //         11129715693094986530,
    //         14839879005967945333,
    //         131776332513548278,
    //     ]; // this has a most sig of 1 not shown; mod of this should be 'expected'

    //     let fpx = fp_256::Fp256::new(x);
    //     assert_eq!(fpx.normalize_little(1), expected);

    //     assert_eq!(
    //         fp_256::Fp256::new([
    //             1658067930733296012,
    //             13547302404868533267,
    //             9458636050195978030,
    //             9117568210736327771
    //         ]) + fp_256::Fp256::new([
    //             15892895009107896966,
    //             16029157361936004879,
    //             5381242955771967302,
    //             9460952195486772123
    //         ]),
    //         expected
    //     );
    //     assert_eq!(a * (b + c), a * b + a * c);
    //     assert_eq!(a * (b + c), expected);

    //     let max = fp_256::Fp256::new([
    //         0xFFFFFFFFFFFFFFFF,
    //         0xFFFFFFFFFFFFFFFF,
    //         0xFFFFFFFFFFFFFFFF,
    //         0xFFFFFFFFFFFFFFFF,
    //     ]);
    //     assert_eq!(
    //         max.normalize_big(0),
    //         fp_256::Fp256::new([
    //             16691276537507834264,
    //             1271272038023711329,
    //             6165449088192685022,
    //             8091559079779792902
    //         ])
    //     );
    //     assert_eq!(
    //         max.normalize_big(1),
    //         fp_256::Fp256::new([
    //             13180341465104399562,
    //             3813816114071133989,
    //             49603190868503450,
    //             5827933165629827091
    //         ])
    //     );
    // }

    #[test]
    fn test_from_sha_static() {
        let x = [1u8; 64];
        let expected = fp_256::Fp256::new([
            943682914, 296735281, 102601666, 655105971, 441508414, 1938904809, 1433209327,
            308023271, 117,
        ]);
        assert_eq!(fp_256::Fp256::from(x), expected);

        let mut x = [0u8; 64];
        x[16..32].iter_mut().for_each(|i| *i = 1);
        x[48..64].iter_mut().for_each(|i| *i = 1);
        let expected = fp_256::Fp256::new([
            967511966, 1307044956, 1229633257, 566771625, 922104236, 1401873859, 1287751493,
            1191577462, 120,
        ]);
        assert_eq!(fp_256::Fp256::from(x), expected);
    }

    #[test]
    fn fp256_to_bytes_known_good_value() {
        use fp_256::Fp256;
        let fp = Fp256::from(255u32);
        let bytes = fp.to_bytes_array();
        let expected_result = {
            let mut array = [0u8; 32];
            array[31] = 255;
            array
        };
        assert_eq!(bytes, expected_result);
    }

    #[test]
    fn fp256_from_bytes_should_mod() {
        use fp_256::Fp256;
        let max_bytes = Fp256::from([255u8; 32]);
        let expected_result = Fp256::new([
            569862552, 1330030375, 2099849607, 220445046, 1739734497, 839018739, 1461584277,
            629083738, 112,
        ]);
        assert_eq!(max_bytes, expected_result);
        let to_bytes_result = max_bytes.to_bytes_array();
        assert_eq!(
            to_bytes_result,
            [
                112, 74, 254, 28, 181, 92, 120, 6, 85, 144, 19, 71, 158, 123, 35, 222, 17, 164,
                119, 46, 223, 74, 74, 97, 231, 163, 83, 147, 161, 247, 105, 152
            ]
        );
    }
}
